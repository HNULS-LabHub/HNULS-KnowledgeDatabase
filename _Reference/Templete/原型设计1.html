<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LightRAG Visualizer - White Tech Theme</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #F8FAFC; /* Slate 50 极简白底 */
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* 鼠标样式指示 */
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }

        /* 毛玻璃 UI 面板 */
        .glass-panel {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 10px 40px -10px rgba(14, 30, 37, 0.08);
        }

        /* 搜索框发光特效 */
        .search-input:focus {
            box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.3), 0 4px 14px 0 rgba(0, 118, 255, 0.1);
            outline: none;
            border-color: #38BDF8;
        }

        /* 自定义滚动条 */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #CBD5E1; border-radius: 10px; }
    </style>
</head>
<body>

    <!-- Canvas 渲染容器 -->
    <div id="canvas-container" class="cursor-grab">
        <canvas id="kg-canvas"></canvas>
    </div>

    <!-- 顶部导航与搜索区域 -->
    <div class="absolute top-6 left-1/2 transform -translate-x-1/2 z-10 w-full max-w-2xl px-4">
        <div class="glass-panel rounded-2xl p-2 flex items-center transition-all duration-300 hover:shadow-lg">
            <div class="flex-shrink-0 px-4 flex items-center gap-2 border-r border-slate-200">
                <div class="w-3 h-3 rounded-full bg-blue-500 animate-pulse"></div>
                <span class="font-bold text-slate-800 tracking-wide">LightRAG</span>
            </div>
            <div class="flex-grow flex items-center relative pl-4">
                <i class="fas fa-search text-slate-400 absolute left-4"></i>
                <input type="text" id="search-box" class="search-input w-full bg-transparent border border-transparent py-3 pl-8 pr-4 text-slate-700 placeholder-slate-400 rounded-xl transition-all" placeholder="输入检索问题，例如: '什么是大型语言模型？'">
            </div>
            <button id="search-btn" class="ml-2 bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white px-6 py-3 rounded-xl font-medium shadow-md shadow-blue-500/20 transition-all transform hover:scale-105 active:scale-95">
                检索
            </button>
        </div>
    </div>

    <!-- 左下角信息统计面板 -->
    <div class="absolute bottom-6 left-6 z-10">
        <div class="glass-panel rounded-xl p-5 w-64">
            <h3 class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-4">图谱状态 (Graph Stats)</h3>
            <div class="space-y-4">
                <div class="flex justify-between items-center">
                    <div class="flex items-center gap-2">
                        <div class="w-2 h-2 rounded-full bg-pink-500"></div>
                        <span class="text-sm text-slate-600 font-medium">查询节点 (Query)</span>
                    </div>
                    <span class="text-sm font-bold text-slate-800" id="stat-query">0</span>
                </div>
                <div class="flex justify-between items-center">
                    <div class="flex items-center gap-2">
                        <div class="w-2 h-2 rounded-full bg-purple-500"></div>
                        <span class="text-sm text-slate-600 font-medium">实体节点 (Entities)</span>
                    </div>
                    <span class="text-sm font-bold text-slate-800" id="stat-entities">0</span>
                </div>
                <div class="flex justify-between items-center">
                    <div class="flex items-center gap-2">
                        <div class="w-2 h-2 rounded-full bg-emerald-500"></div>
                        <span class="text-sm text-slate-600 font-medium">文档块 (Chunks)</span>
                    </div>
                    <span class="text-sm font-bold text-slate-800" id="stat-chunks">0</span>
                </div>
                <div class="pt-3 border-t border-slate-200 flex justify-between items-center">
                    <span class="text-sm text-slate-600 font-medium">关系总数 (Edges)</span>
                    <span class="text-sm font-bold text-slate-800" id="stat-edges">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- 右下角镜头控制面板 -->
    <div class="absolute bottom-6 right-6 z-10 flex gap-2">
        <button id="btn-zoom-in" class="glass-panel w-12 h-12 rounded-full flex items-center justify-center text-slate-600 hover:text-blue-600 hover:bg-white transition-colors shadow-sm">
            <i class="fas fa-plus"></i>
        </button>
        <button id="btn-zoom-out" class="glass-panel w-12 h-12 rounded-full flex items-center justify-center text-slate-600 hover:text-blue-600 hover:bg-white transition-colors shadow-sm">
            <i class="fas fa-minus"></i>
        </button>
        <button id="btn-reset" class="glass-panel w-12 h-12 rounded-full flex items-center justify-center text-slate-600 hover:text-blue-600 hover:bg-white transition-colors shadow-sm" title="重置视角">
            <i class="fas fa-expand"></i>
        </button>
    </div>

    <!-- 检索状态遮罩 (隐藏) -->
    <div id="retrieval-overlay" class="absolute top-24 left-1/2 transform -translate-x-1/2 z-10 transition-opacity duration-300 opacity-0 pointer-events-none">
        <div class="bg-white/90 backdrop-blur-md border border-blue-100 shadow-xl rounded-full px-6 py-2 flex items-center gap-3">
            <i class="fas fa-circle-notch fa-spin text-blue-500" id="status-icon"></i>
            <span class="text-sm font-medium text-slate-700" id="status-text">LightRAG 深度检索中...</span>
        </div>
    </div>

    <script>
        /**
         * LightRAG Canvas 渲染引擎 (渐进式弹簧物理引擎)
         */
        const canvas = document.getElementById('kg-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const container = document.getElementById('canvas-container');

        // 视图变换状态 (镜头)
        let transform = { x: 0, y: 0, scale: 1 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };

        // 状态
        let animationFrameId;
        let isRetrieving = false;

        // 数据结构 (初始为空)
        let graph = {
            nodes: [],
            edges: []
        };

        // 颜色配置
        const THEME = {
            background: '#F8FAFC', 
            line: '#CBD5E1',       
            lineActive: '#94A3B8', 
            text: '#475569',       
            textGlow: '#FFFFFF',   
            edgeText: '#64748B',   
            types: {
                'query':    { color: '#EC4899', glow: 'rgba(236, 72, 153, 0.5)' }, // 中心搜索词
                'entity':   { color: '#8B5CF6', glow: 'rgba(139, 92, 246, 0.4)' }, // 一级实体
                'chunk':    { color: '#10B981', glow: 'rgba(16, 185, 129, 0.4)' }  // 二级文档块
            }
        };

        // 1. 初始化并调整 Canvas 尺寸
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
            
            if (transform.scale === 1 && transform.x === 0) {
                transform.x = window.innerWidth / 2;
                transform.y = window.innerHeight / 2;
            }
        }
        window.addEventListener('resize', resizeCanvas);

        // 2. 镜头控制逻辑 (缩放与平移)
        container.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStart = { x: e.clientX - transform.x, y: e.clientY - transform.y };
            container.classList.replace('cursor-grab', 'cursor-grabbing');
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            transform.x = e.clientX - dragStart.x;
            transform.y = e.clientY - dragStart.y;
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            container.classList.replace('cursor-grabbing', 'cursor-grab');
        });

        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSensitivity = 0.001;
            const delta = e.deltaY * -zoomSensitivity;
            const newScale = Math.min(Math.max(0.1, transform.scale * (1 + delta)), 5);
            
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            
            transform.x = mouseX - (mouseX - transform.x) * (newScale / transform.scale);
            transform.y = mouseY - (mouseY - transform.y) * (newScale / transform.scale);
            transform.scale = newScale;
        }, { passive: false });

        function zoom(factor) {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const newScale = Math.min(Math.max(0.1, transform.scale * factor), 5);
            
            transform.x = centerX - (centerX - transform.x) * (newScale / transform.scale);
            transform.y = centerY - (centerY - transform.y) * (newScale / transform.scale);
            transform.scale = newScale;
        }
        document.getElementById('btn-zoom-in').addEventListener('click', () => zoom(1.3));
        document.getElementById('btn-zoom-out').addEventListener('click', () => zoom(0.7));
        document.getElementById('btn-reset').addEventListener('click', () => {
            transform = { x: window.innerWidth / 2, y: window.innerHeight / 2, scale: 1 };
        });

        // 更新左下角统计 UI
        function updateStats() {
            document.getElementById('stat-query').innerText = graph.nodes.filter(n => n.type === 'query').length;
            document.getElementById('stat-entities').innerText = graph.nodes.filter(n => n.type === 'entity').length;
            document.getElementById('stat-chunks').innerText = graph.nodes.filter(n => n.type === 'chunk').length;
            document.getElementById('stat-edges').innerText = graph.edges.length;
        }

        // 3. 渲染循环
        function draw() {
            // 填充科技白背景
            ctx.fillStyle = THEME.background;
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

            ctx.save();
            ctx.translate(transform.x, transform.y);
            ctx.scale(transform.scale, transform.scale);

            // 更新节点物理动画 (弹簧物理：恰到好处的跳动)
            graph.nodes.forEach(node => {
                // 弹性系数(Tension) 和 阻尼系数(Friction)
                const tension = 0.2; 
                const friction = 0.65; 
                
                node.v += (node.targetScale - node.scale) * tension;
                node.v *= friction;
                node.scale += node.v;
                
                // 静态位置，不加漂浮
                node.x = node.baseX;
                node.y = node.baseY;
            });

            // 绘制连线及线上的描述文字
            graph.edges.forEach(edge => {
                // 连线生长动画 (平滑的 Ease-out)
                edge.progress += (edge.targetProgress - edge.progress) * 0.15;
                
                if (edge.progress < 0.01) return; // 还没开始长

                const t = edge.progress;
                const p0 = edge.source;
                const p1 = edge.cp; // 贝塞尔控制点
                const p2 = edge.target;

                // 使用 De Casteljau 算法计算贝塞尔曲线的局部绘制点 (实现曲线顺滑生长的动画)
                const cp1x = p0.x + (p1.x - p0.x) * t;
                const cp1y = p0.y + (p1.y - p0.y) * t;
                const endX = Math.pow(1-t, 2) * p0.x + 2 * (1-t) * t * p1.x + Math.pow(t, 2) * p2.x;
                const endY = Math.pow(1-t, 2) * p0.y + 2 * (1-t) * t * p1.y + Math.pow(t, 2) * p2.y;

                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                ctx.quadraticCurveTo(cp1x, cp1y, endX, endY);
                
                ctx.strokeStyle = THEME.line;
                ctx.lineWidth = 1.5 / transform.scale;
                ctx.stroke();

                // 绘制边上的描述文字 (Description) - 连线即将到达时淡入
                if (edge.description && edge.progress > 0.8 && edge.target.scale > 0.5) {
                    // 二次贝塞尔曲线在 t=0.5 处的中点坐标
                    const midX = 0.25 * p0.x + 0.5 * p1.x + 0.25 * p2.x;
                    const midY = 0.25 * p0.y + 0.5 * p1.y + 0.25 * p2.y;
                    
                    // 数学特性：二次贝塞尔曲线在 t=0.5 处的切线，正好平行于起点和终点的连线
                    let angle = Math.atan2(p2.y - p0.y, p2.x - p0.x);
                    
                    if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                        angle += Math.PI;
                    }

                    ctx.save();
                    ctx.translate(midX, midY);
                    ctx.rotate(angle);
                    
                    ctx.globalAlpha = Math.min(1, (edge.progress - 0.8) * 5); // 顺滑淡入透明度
                    
                    ctx.font = `500 ${10 / transform.scale}px Inter`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    
                    ctx.lineWidth = 3 / transform.scale;
                    ctx.strokeStyle = THEME.background; 
                    ctx.strokeText(edge.description, 0, -3 / transform.scale);
                    
                    ctx.fillStyle = THEME.edgeText;
                    ctx.fillText(edge.description, 0, -3 / transform.scale);
                    
                    ctx.restore();
                }
            });

            // 绘制节点
            graph.nodes.forEach(node => {
                if (node.scale < 0.01) return; // 没长出来就不画

                const themeDef = THEME.types[node.type];
                const actualSize = Math.max(0.1, node.size * node.scale); // 防止负数半径报错

                ctx.beginPath();
                ctx.arc(node.x, node.y, actualSize, 0, Math.PI * 2);
                
                ctx.fillStyle = themeDef.color;
                // 根据缩放比例动态调整发光大小
                ctx.shadowBlur = Math.max(0, 15 * node.scale);
                ctx.shadowColor = themeDef.glow;
                ctx.fill();

                // 内发光/立体感 (白圈)
                ctx.lineWidth = 2 / transform.scale;
                ctx.strokeStyle = '#FFFFFF';
                ctx.stroke();
                ctx.shadowBlur = 0;

                // 绘制节点文字标签 - 伴随节点生长顺滑淡入
                if (transform.scale > 0.5 || node.size > 12) {
                    if (node.scale > 0.2) {
                        ctx.save();
                        ctx.globalAlpha = Math.min(1, (node.scale - 0.2) * 1.5);
                        
                        ctx.font = `bold ${11 / transform.scale}px Inter, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        
                        ctx.lineWidth = 3 / transform.scale;
                        ctx.strokeStyle = THEME.textGlow;
                        ctx.strokeText(node.label, node.x, node.y + actualSize + 5);
                        
                        ctx.fillStyle = THEME.text;
                        ctx.fillText(node.label, node.x, node.y + actualSize + 5);
                        ctx.restore();
                    }
                }
            });

            ctx.restore();
            animationFrameId = requestAnimationFrame(draw);
        }

        // 4. 模拟渐进式检索交互 (LightRAG Process - 逐个生长动画)
        async function simulateRetrieval() {
            if(isRetrieving) return;
            
            const input = document.getElementById('search-box').value || "什么是大型语言模型？";
            const btn = document.getElementById('search-btn');
            const overlay = document.getElementById('retrieval-overlay');
            const statusText = document.getElementById('status-text');
            const statusIcon = document.getElementById('status-icon');
            
            // 状态重置
            isRetrieving = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            overlay.classList.remove('opacity-0');
            statusText.innerText = "提取核心意图 (Query Extraction)...";
            
            // 清空现有图谱并重置视角
            graph.nodes = [];
            graph.edges = [];
            transform = { x: window.innerWidth / 2, y: window.innerHeight / 2, scale: 1 };
            updateStats();

            // 步骤 1: 生成中心 Query 节点
            const centerNode = {
                id: 'center_query',
                label: input.length > 10 ? input.substring(0, 10) + '...' : input,
                type: 'query',
                x: 0, y: 0, baseX: 0, baseY: 0,
                size: 24, scale: 0, targetScale: 1, v: 0 // v 代表物理速度
            };
            graph.nodes.push(centerNode);
            updateStats();

            await sleep(600); // 留出让中心节点弹出的时间

            // 步骤 2: 一级发散 (逐个长出连线和实体，加入位置噪声)
            statusText.innerText = "一级发散: 召回相关实体 (Entity Retrieval)...";
            const entityLabels = ['LLM', 'Transformer', 'Attention Mechanism', 'Context Window', 'Tokenization'];
            const entityDescriptions = ['属于', '底层架构', '核心机制', '影响限制', '数据处理'];
            const l1Nodes = [];
            
            const l1RadiusBase = 180;
            for(let i=0; i<entityLabels.length; i++) {
                // 基础角度均匀分布，在此基础上加入随机噪声破坏规律感
                const baseAngle = (i / entityLabels.length) * Math.PI * 2;
                const angleNoise = (Math.random() - 0.5) * 0.6; // 角度偏移噪声
                const finalAngle = baseAngle + angleNoise;
                
                // 半径也加入大幅度噪声，使得节点不再是一个完美的圆环
                const radiusNoise = (Math.random() - 0.5) * 80; 
                const finalRadius = l1RadiusBase + radiusNoise;

                const node = {
                    id: `e_${i}`,
                    label: entityLabels[i],
                    type: 'entity',
                    x: Math.cos(finalAngle) * finalRadius, y: Math.sin(finalAngle) * finalRadius,
                    baseX: Math.cos(finalAngle) * finalRadius, baseY: Math.sin(finalAngle) * finalRadius,
                    size: 16, scale: 0, targetScale: 0, v: 0 // 初始不显示
                };
                graph.nodes.push(node);
                l1Nodes.push(node);

                // 生成带有随机弯曲方向和随机曲率的贝塞尔控制点
                const dx = node.x - centerNode.x;
                const dy = node.y - centerNode.y;
                const curveSign = Math.random() > 0.5 ? 1 : -1;
                const curvature = curveSign * (0.1 + Math.random() * 0.15); // 曲率加入随机性
                const cp = {
                    x: (centerNode.x + node.x) / 2 - dy * curvature,
                    y: (centerNode.y + node.y) / 2 + dx * curvature
                };

                const edge = {
                    source: centerNode, target: node,
                    cp: cp, // 存入控制点
                    description: entityDescriptions[i],
                    progress: 0, targetProgress: 1 // 触发连线生长
                };
                graph.edges.push(edge);
                updateStats();

                // 等待连线“长”过去，再让节点“弹”出来
                await sleep(150); 
                node.targetScale = 1; 
                await sleep(150); // 下一个分支生长的间隔
            }

            await sleep(400);

            // 步骤 3: 二级发散 (底层文档 Chunk 关联 - 同样逐个生长并加入噪声)
            statusText.innerText = "二级发散: 定位文档上下文 (Chunk Retrieval)...";
            
            const l2RadiusOffsetBase = 150;
            for(let i=0; i<l1Nodes.length; i++) {
                const parent = l1Nodes[i];
                const childCount = Math.floor(Math.random() * 3) + 2; 
                const baseAngle = Math.atan2(parent.baseY, parent.baseX); 
                
                for(let j=0; j<childCount; j++) {
                    const spread = Math.PI / 2.5; // 稍微扩大扇形展开角度
                    // 计算基础的扇形内角度，并加入噪声
                    const baseChildAngle = baseAngle - spread/2 + (j / (childCount - 1 || 1)) * spread;
                    const angleNoise = (Math.random() - 0.5) * 0.5; // 二级节点角度噪声
                    const finalAngle = baseChildAngle + angleNoise;
                    
                    // 距离加入大幅度随机噪声，形成远近错落有致的层级
                    const distNoise = (Math.random() - 0.5) * 120;
                    const chunkDist = Math.sqrt(parent.baseX**2 + parent.baseY**2) + l2RadiusOffsetBase + distNoise;
                    
                    const node = {
                        id: `c_${i}_${j}`,
                        label: `Chunk: Doc_${Math.floor(Math.random()*900)+100}`,
                        type: 'chunk',
                        x: Math.cos(finalAngle) * chunkDist, y: Math.sin(finalAngle) * chunkDist,
                        baseX: Math.cos(finalAngle) * chunkDist, baseY: Math.sin(finalAngle) * chunkDist,
                        size: 10, scale: 0, targetScale: 0, v: 0
                    };
                    graph.nodes.push(node);

                    // 生成贝塞尔控制点，曲率同样随机化
                    const dx = node.x - parent.x;
                    const dy = node.y - parent.y;
                    const curveSign = Math.random() > 0.5 ? 1 : -1;
                    const curvature = curveSign * (0.15 + Math.random() * 0.2); // 二级分支曲率随机
                    const cp = {
                        x: (parent.x + node.x) / 2 - dy * curvature,
                        y: (parent.y + node.y) / 2 + dx * curvature
                    };

                    const edge = {
                        source: parent, target: node,
                        cp: cp, // 存入控制点
                        description: ['包含', '提及', '定义', '论证'][Math.floor(Math.random()*4)],
                        progress: 0, targetProgress: 1
                    };
                    graph.edges.push(edge);
                    updateStats();

                    // 连线生长的微小时差
                    await sleep(60);
                    node.targetScale = 1; // 节点跳出
                    await sleep(60);
                }
            }

            await sleep(1000);

            // 步骤 4: 结束检索
            statusText.innerText = "检索完成，生成答案中...";
            statusIcon.classList.replace('fa-circle-notch', 'fa-check-circle');
            statusIcon.classList.remove('fa-spin');
            
            await sleep(1500);
            
            isRetrieving = false;
            btn.innerHTML = '检索';
            overlay.classList.add('opacity-0');
            
            setTimeout(() => {
                statusIcon.classList.replace('fa-check-circle', 'fa-circle-notch');
                statusIcon.classList.add('fa-spin');
            }, 500);
        }

        // 辅助延迟函数
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        document.getElementById('search-btn').addEventListener('click', simulateRetrieval);
        document.getElementById('search-box').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') simulateRetrieval();
        });

        // 启动应用基础环境
        resizeCanvas();
        draw(); 
        // 去掉了初始的 generateMockData()，图谱默认保持干净空白
    </script>
</body>
</html>