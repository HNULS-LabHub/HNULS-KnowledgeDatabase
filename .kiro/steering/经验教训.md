---
inclusion: always
---
<!------------------------------------------------------------------------------------
   Add rules to this file or a short description and have Kiro refine them for you.
   
   Learn about inclusion modes: https://kiro.dev/docs/steering/#inclusion-modes
-------------------------------------------------------------------------------------> 
## Electron 多进程架构中 SurrealDB Record ID 的教训

SurrealDB JS SDK 返回的 Record ID 不是普通字符串，而是带有 `.toString()` 方法的 `RecordId` 对象。在同一个进程内，SDK 的 `db.query()` 能正确处理这个对象（vector-indexer 就是这么用的，从来没出过问题）。但一旦通过 Electron IPC（`parentPort.postMessage`）跨进程传递，对象被序列化为普通 JSON `{ tb: 'table', id: 'xxx' }`，丢失了方法，SurrealDB 的 `record<table>` 类型字段就不认了。

### 最终解决方案：彻底绕过 RecordId 对象

**不再依赖 SDK 自动生成的 RecordId**，改为自己生成纯字符串 ID：

```typescript
// ID 生成函数
function generateTaskId(): string {
  return `kg_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`
}

// 创建记录时使用 type::thing() 指定 ID
const sql = `CREATE type::thing('kg_task', $taskId) CONTENT {...}`

// 后续操作直接拼 SQL（ID 是纯字符串，如 "kg_task:kg_xxx"）
await client.query(`UPDATE ${taskIdStr} SET ...`)
await client.query(`DELETE ${chunkIdStr}`)
```

**核心原则**：
1. ID 由程序自己生成，格式如 `kg_1707654321000_a1b2c3`
2. 创建记录用 `type::thing('table', $id)` 语法
3. UPDATE/DELETE 直接拼 SQL，不用参数化的 `$recordId`
4. WHERE 子句中的字符串匹配仍可用参数化（如 `WHERE task_id = $taskId`）

这样 ID 始终是纯字符串，跨 IPC、跨进程都没问题，彻底告别 RecordId 对象的坑。